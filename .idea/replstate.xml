<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1396566319783">{:repl-history {:ide [], :local [&quot;(+1 1)&quot; &quot;(+ 1 1)&quot; &quot;\&quot;FIXME, I fail.\&quot;&quot; &quot;is (= 0 1)&quot; &quot;(is (= {:x 1 :y 0 :bearing :north} {:x 0 :y 0 :bearing :north}))&quot; &quot;(is (= {:x 0 :y 0 :bearing :north} {:x 0 :y 0 :bearing :north}))&quot; &quot;(println \&quot;Hello, World!\&quot;)&quot; &quot;(testing \&quot;Mars rover movements\&quot;\n  (testing \&quot;The rover stays in the same position if it gets no commands\&quot;\n    (is (= {:x 0 :y 0 :bearing :north} {:x 0 :y 0 :bearing :north}))))&quot; &quot;[]&quot; &quot;[:a :b :c]&quot; &quot;[:a :b :c][1]&quot; &quot;get [:a :b :c]&quot; &quot;get [:a :b :c] 1&quot; &quot;(get [:a :b :c] 1)&quot; &quot;(def ^:private forward-displacements {:north {:delta-x 0  :delta-y 1}\n                                      :east  {:delta-x 1  :delta-y 0}\n                                      :south {:delta-x -1 :delta-y 0}\n                                      :west  {:delta-x 0  :delta-y -1}})&quot; &quot;(defn- backward-displacements [bearing]\n  (let [{delta-x :delta-x delta-y :delta-y} forward-displacements]\n    {:delta-x (- delta-x) :delta-y (- delta-y)})\n  )&quot; &quot;(defn- calculate-displacement [bearing command]\n  (get { \&quot;F\&quot; (forward-displacements bearing)\n         \&quot;B\&quot; (backward-displacements bearing)\n         } command {:delta-x 0 :delta-y 0})\n  )&quot; &quot;(defn- is-coordinate-an-obstacle? [coordinate obstacles]\n  (some #(= (coordinate %)) obstacles)\n  )&quot; &quot;obstacles = [{:x 1 :y 1}]&quot; &quot;(def obstacles [{:x 1 :y 1}])&quot; &quot;is-coordinate-an-obstacle? {:x 1 :y 0} obstacles&quot; &quot;(if (is-coordinate-an-obstacle? {:x 1 :y 0} obstacles) (println \&quot;yes\&quot;) (println \&quot;no\&quot;)) &quot; &quot;(if (is-coordinate-an-obstacle? {:x 1 :y 1} obstacles) (println \&quot;yes\&quot;) (println \&quot;no\&quot;)) &quot; &quot;obstacles&quot; &quot;(calculate-displacement :north \&quot;F\&quot;)&quot; &quot;(is-coordinate-an-obstacle? {:x 1 :y 1} obstacles) &quot; &quot;(is-coordinate-an-obstacle? {:x 1 :y 0} obstacles) &quot; &quot;(= {:x 1} {:x 2})&quot; &quot;(= {:x 1} {:x 1})&quot; &quot;(= {:x 1} {:x 1 :y 1})&quot; &quot;(= {:x 1 :y 1} {:x 1 :y 1})&quot; &quot;(= {:x 1 :y 1} {:x 1 :y 2})&quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 0} obstacles) &quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 0} []) &quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 0} [{:x 0 :y 1}]) &quot; &quot;(some #(= ({:x 0 :y 0} %)) [{:x 0 :y 1}]) &quot; &quot;(some #(if(= ({:x 0 :y 0} %)) %) [{:x 0 :y 1}]) &quot; &quot;(some #(if(= ({:x 0 :y 0} %)) %) [{:x 0 :y 2}]) &quot; &quot;(some #(= ({:x 0 :y 0} %) %) [{:x 0 :y 2}]) &quot; &quot;(some #(= ({:x 0 :y 0} %) %) [{:x 0 :y 1}]) &quot; &quot;(some #(= ({:x 0 :y 0} %) %) [{:x 0 :y 0}]) &quot; &quot;(some #(= ({:x 0 :y 0} %)) [{:x 0 :y 0}]) &quot; &quot;(some #(= (% {:x 0 :y 0})) [{:x 0 :y 0}]) &quot; &quot;(some #(println %) [{:x 0 :y 0}]) &quot; &quot;(some #(println %) [{:x 0 :y 0} { :x 2 :y 2}]) &quot; &quot;(some #(println (= % %)) [{:x 0 :y 0} { :x 2 :y 2}]) &quot; &quot;(some #(println (= % {:x 0 :y 0})) [{:x 0 :y 0} { :x 2 :y 2}]) &quot; &quot;(some #(= % {:x 0 :y 0}) [{:x 0 :y 0} { :x 2 :y 2}]) &quot; &quot;(some #(= % {:x 0 :y 0}) [{:x 1 :y 0} { :x 2 :y 2}]) &quot; &quot;(some #(= % {:x 0 :y 0}) obstacles) &quot; &quot;(some #(= % {:x 1 :y 0}) obstacles) &quot; &quot;(some #(= % {:x 1 :y 1}) obstacles) &quot; &quot;(is-coordinate-an-obstacle? {:x 1 :y 1} obstacles)&quot; &quot;(is-coordinate-an-obstacle? {:x 1 :y 0} obstacles)&quot; &quot;(if true 1 2)&quot; &quot;(if false 1 2)&quot; &quot;(if nil 1 2)&quot; &quot;(ns rover.core-test\n  (:require [clojure.test :refer :all]\n            [rover.core :refer :all]))\n\n(defn- calculate-rotation[command]\n  (get {\&quot;R\&quot; 1 \&quot;L\&quot; -1} command 0)\n  )\n\n(defn- calculate-new-bearing [old-bearing command]\n  (let [all-bearings [:north :east :south :west]]\n    (let [new-index (+ (calculate-rotation command) (.indexOf all-bearings old-bearing))]\n      (get all-bearings (mod new-index (count all-bearings))\n           )\n      )\n    )\n  )\n\n(def ^:private forward-displacements {:north {:delta-x 0  :delta-y 1 }\n                                      :east  {:delta-x 1  :delta-y 0 }\n                                      :south {:delta-x 0  :delta-y -1}\n                                      :west  {:delta-x -1 :delta-y 0 }})\n\n(defn- backward-displacements [bearing]\n  (let [{delta-x :delta-x delta-y :delta-y} (forward-displacements bearing)]\n    {:delta-x (- delta-x) :delta-y (- delta-y)})\n  )\n\n(defn- calculate-displacement [bearing command]\n  (get { \&quot;F\&quot; (forward-displacements bearing)\n         \&quot;B\&quot; (backward-displacements bearing)\n         } command {:delta-x 0 :delta-y 0})\n  )\n\n(def ^:private planet-size {:around-x 100 :around-y 100}\n  )\n\n(defn- is-coordinate-an-obstacle? [coordinate obstacles]\n  (some #(= % coordinate) obstacles)\n  )\n\n(defn- calculate-new-coordinates [position command]\n  (let [{x :x y :y bearing :bearing} position]\n    (let [{delta-x :delta-x delta-y :delta-y} (calculate-displacement bearing command)]\n      {:x (mod (+ x delta-x) (planet-size :around-x))\n       :y (mod (+ y delta-y) (planet-size :around-y))}\n      )\n    )\n  )\n\n(defn move-rover [initial-position commands obstacles]\n  (letfn [(do-command [position command]\n                      (let [{bearing :bearing} position]\n                        (let [{new-x :x new-y :y} (calculate-new-coordinates position command)]\n                          (if (is-coordinate-an-obstacle? {:x new-x :y new-y} obstacles)\n                            (println \&quot;tstd\&quot;)\n                            {:x new-x :y new-y :bearing (calculate-new-bearing bearing command)}\n                            )\n                          )\n                        )\n                      )]\n    )\n  (reduce do-command initial-position (map str commands))\n  )\n\n(deftest mars-rover-movements\n  (testing \&quot;The rover stays in the same position if it gets no commands\&quot;\n    (is (= {:x 0 :y 0 :bearing :north} (move-rover {:x 0 :y 0 :bearing :north} \&quot;\&quot; []))))\n  (testing \&quot;The rover moves forward\&quot;\n    (is (= {:x 0 :y 1 :bearing :north} (move-rover {:x 0 :y 0 :bearing :north} \&quot;F\&quot; []))))\n  (testing \&quot;The rover moves backwards\&quot;\n    (is (= {:x 0 :y 1 :bearing :north} (move-rover {:x 0 :y 2 :bearing :north} \&quot;B\&quot; []))))\n  (testing \&quot;The rover moves forward twice\&quot;\n    (is (= {:x 0 :y 2 :bearing :north} (move-rover {:x 0 :y 0 :bearing :north} \&quot;FF\&quot; []))))\n  (testing \&quot;The rover rotates right\&quot;\n    (is (= {:x 0 :y 0 :bearing :east} (move-rover {:x 0 :y 0 :bearing :north} \&quot;R\&quot; []))))\n  (testing \&quot;The rover rotates right twice\&quot;\n    (is (= {:x 0 :y 0 :bearing :south} (move-rover {:x 0 :y 0 :bearing :north} \&quot;RR\&quot; []))))\n  (testing \&quot;The rover rotates left\&quot;\n    (is (= {:x 0 :y 0 :bearing :west} (move-rover {:x 0 :y 0 :bearing :north} \&quot;L\&quot;[]))))\n  (testing \&quot;The rover moves forward while heading east\&quot;\n    (is (= {:x 1 :y 0 :bearing :east} (move-rover {:x 0 :y 0 :bearing :east} \&quot;F\&quot; []))))\n  (testing \&quot;The position wraps arround 100 because the planet is round\&quot;\n    (is (= {:x 1 :y 99 :bearing :east} (move-rover {:x 99 :y 1 :bearing :south} \&quot;FFLFF\&quot; []))))\n  (testing \&quot;The rover stops when it encounters an obstacle\&quot;\n    (is (= {:x 0 :y 2 :bearing :north} (move-rover {:x 0 :y 0 :bearing :north} \&quot;FFFF\&quot; [{:x 0 :y 3}])))))&quot; &quot;(move-rover {:x 0 :y 0 :bearing :north} \&quot;FFFF\&quot; [{:x 0 :y 3}])\n&quot; &quot;(defn- is-coordinate-an-obstacle? [coordinate obstacles]\n  (some #(= % coordinate) obstacles)\n  )&quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 1})&quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 1} [])&quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 1} [{}])&quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 1} [{:x 0 :y 1}])&quot; &quot;(is-coordinate-an-obstacle? {:x 0 :y 1} [{:x 0 :y 2}])&quot; &quot;(if (is-coordinate-an-obstacle? {:x 0 :y 1} [{:x 0 :y 2}]) 123 321)&quot; &quot;(if (is-coordinate-an-obstacle? {:x 0 :y 1} [{:x 0 :y 1}]) 123 321)&quot; &quot;(move-rover {:x 0 :y 0 :bearing :north} \&quot;FFFF\&quot; [{:x 0 :y 3}])&quot;], :remote []}}</component>
</project>

